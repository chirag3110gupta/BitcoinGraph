# CS 225 Final Project: Development

## Week 1:

- (***@team***) **November 13, 2020:** Today we all had our first group meeting during which we drafted and submitted our team contract and project proposal. Afterwards, Adit cleaned up the data while we discussed what characteristics and information to eliminate so he can do so. Adit and Aliva are both CS + Music majors so they did a lot of the eliminating of those characteristics, of course still running it by the other teammates and justifying the decisions. First and foremost, we all agreed in removing audiobooks and tracks which usually scored extremes on most relevant features, such as: white noise, nature sounds, etc… These items really made the dataset a lot more dense than it needed to be; they also don’t really fall under the scope of our project.

- (***@aditk3***) **November 13, 2020:** I used the Pandas Python library in a Jupyter Notebook environment to easily manipulate the data and get rid of unnecessary entries like audiobooks. I also tried figuring out different characteristics (columns) of the dataset that were not too important with my teammates over a Discord call and removed them, producing a cleaner dataset.

- (***@team***) **November 20, 2020:** Today we were unfortunately notified by our TA that our project idea does not fit in with the criteria of the actual project specs. We reconvened and chose a new data set, which we then cleaned up and prepared a new project proposal.

## Week 2:

- (***@team***) **November 23, 2020:** After receiving approval to proceed with our newly formed project idea we had another meeting today. We had a high level discussion in the design of our program and then began programming the skeleton as well as delegating tasks to establish a workflow. Chirag worked on the User class, while Adit worked on the Transactions class. Anit was responsible for the Graph class, in which Aliva was assigned the implementation of the BFS traversal. We also established our codestyle guidelines as well as workflow rules. Since Aliva is familiar with Git she explained the usage of branches to the rest of the team. We wrote a set of Git guidelines for the team, the main stipulation being that we all work in our own branches, leaving master as the latest functioning version of our codebase; merges into master are not permitted unless an individuals code is properly working. We also began using issues as well as a project board which can to assign tasks as well as keep record of our progress and document bugs and recommendations to one another. This can be seen in our repository.
- (***@chiragg4***) **November 23, 2020:** The User class I worked on acts as a Vertex for the graph. Each user has class variables for storing the number of transactions to and from the user. This will help in implementing page ranking and make it more efficient. The average rating will help us to determine if the user is trusted or not.
- (***@anityak2***) **November 23, 2020:** The graph class that I worked on with Aliva is dependent on the Transaction and User classes implemented by Adit and Chirag. These dependencies enable the graph class to be implemented as an adjacency list, where an unordered map contains each of the Users as Keys, and a pair of Transaction vectors as Values. The first of the two transaction vectors represents the outgoing transactions for the user, and the second contains each of the incoming transactions. We chose this implementation since we felt that having both incoming and outgoing transaction details would help later algorithms be more efficient, as each User would have all of its information stored in one place and retrieving data would be faster. In order to have our implementation be spatially efficient we decided to store user data in each instance of the transaction class as a pointer.
- (***@alivabp2***) **November 24, 2020:** To implement a Breadth First (BFS) traversal of the graph, I needed to first understand the actual process and pseudocode which I did by drawing it out. Essentially, one must traverse the graph in a breadthward motion by using a queue to store visited vertices. As you traverse via adjacent vertices, you mark them as visited and insert them into the queue. If there is no additional adjacent vertex you pop the first vertex and repeat and continue the process until the graph has been traversed. For my implementation, I used a vector of booleans to keep track of visited vertices and a list of integers as my queue. I then tailored the implementation to fit the specific needs of our program; accessing the User ID of the target as the vertex. My teammate Anit helped me with some confusion in regards to accessing necessary objects.

## Week 3:
- (***@team***) **December 3, 2020:** This weeks focus was implementing our algorithms and testing along the way.
- (***@aliva***) **December 4, 2020:** After implementing my BFS traversal, I was advised to make some modifications based on our project specs as we need to use it in the implementation of some of our algorithms. As of now I plan to further modify the BFS traversal and hopefully implement Djikstra's algorithm as well. 
- (***@chiragg4***) **December 4, 2020:** I implemented the Page Rank algorithm which ranks the importance of the node and assigns every node a double value based on other important nodes pointing to it and iterates a number of times which is specified as a parameter. I also reworked our codebase and found that we could work without a separate User class.
- (***@aditk3***) **December 4, 2020:** I first shifted the LoadCSV capabilities into the Graph class and then due to some linking errors, re-implemented the entire class (barring the BFS) to accommodate our new method of storing the data as its graph representation.
- (***@anityak2***) **December 4, 2020:** I completed the Betweenness Centrality algorithm and managed to test it out against values outputted by the networkx library in Python for a test dataset. I used Brandes' Algorithm to implement this and although the final values from my code are integers while the ones given by the networkx algorithm are floats, the relative size of the centrality number holds up for every one of them , which means that the code correctly finds the vertices in the center of the graph.

## Week 4:
- (***@team***) **December 11, 2020:** This week was spent finalizing and completing our project and verifying our resulst! We worked on the CLI implementation and helped write down the bare bones for the interface in the beginning of the week. Then I spent the second half of the week finishing up and cleaning the comments for each of the functions. Besides that, the rest of the time we were testing out the code, cleaning it up and making sure that all parts of the project worked together well. Today we completed our report and presentation!
